"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.permissionBoundary = exports.PermissionsBoundaryAspect = void 0;
const aws_cdk_lib_1 = require("aws-cdk-lib");
const aws_iam_1 = require("aws-cdk-lib/aws-iam");
const iam = require("aws-cdk-lib/aws-iam");
class PermissionsBoundaryAspect {
    constructor(roleName) {
        if (roleName) {
            this.permissionsBoundaryArn = `arn:aws:iam::${aws_cdk_lib_1.Aws.ACCOUNT_ID}:policy/${roleName}`;
        }
        else {
            this.permissionsBoundaryArn = `arn:aws:iam::${aws_cdk_lib_1.Aws.ACCOUNT_ID}:policy/RolePermissionBoundary`;
        }
    }
    visit(node) {
        if (node instanceof aws_iam_1.Role) {
            const roleResource = node.node.findChild("Resource");
            roleResource.addPropertyOverride("PermissionsBoundary", this.permissionsBoundaryArn);
        }
        if (aws_cdk_lib_1.CfnResource.isCfnResource(node) && node.cfnResourceType === 'AWS::IAM::Role') {
            node.addPropertyOverride('PermissionsBoundary', this.permissionsBoundaryArn);
        }
        else if (
        //  This is special bug fix as These are Custom IAM::Role which dont suceed the above statement
        node.toString().includes('AWSCDKOpenIdConnectProviderCustomResourceProvider/Role') ||
            node.toString().includes('AWSCDKCfnUtilsProviderCustomResourceProvider/Role')) {
            const x = node;
            x.addPropertyOverride("PermissionsBoundary", this.permissionsBoundaryArn);
        }
    }
}
exports.PermissionsBoundaryAspect = PermissionsBoundaryAspect;
function permissionBoundary(scope) {
    return iam.ManagedPolicy.fromManagedPolicyName(scope, 'PermissionsBoundary', 'RolePermissionBoundary');
}
exports.permissionBoundary = permissionBoundary;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVybWlzc2lvbnMtYm91bmRhcnktYXNwZWN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGVybWlzc2lvbnMtYm91bmRhcnktYXNwZWN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDZDQUF3RTtBQUN4RSxpREFBb0Q7QUFHcEQsMkNBQTRDO0FBRTVDLE1BQWEseUJBQXlCO0lBSXBDLFlBQVksUUFBaUI7UUFFM0IsSUFBSSxRQUFRLEVBQUU7WUFDWixJQUFJLENBQUMsc0JBQXNCLEdBQUcsZ0JBQWdCLGlCQUFHLENBQUMsVUFBVSxXQUFXLFFBQVEsRUFBRSxDQUFDO1NBQ25GO2FBQU07WUFDTCxJQUFJLENBQUMsc0JBQXNCLEdBQUcsZ0JBQWdCLGlCQUFHLENBQUMsVUFBVSxnQ0FBZ0MsQ0FBQztTQUM5RjtJQUNILENBQUM7SUFFRCxLQUFLLENBQUMsSUFBZ0I7UUFFcEIsSUFBSSxJQUFJLFlBQVksY0FBSSxFQUFFO1lBQ3hCLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBWSxDQUFDO1lBQ2hFLFlBQVksQ0FBQyxtQkFBbUIsQ0FBQyxxQkFBcUIsRUFBRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQztTQUN0RjtRQUFDLElBQUkseUJBQVcsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLGVBQWUsS0FBSyxnQkFBZ0IsRUFBRTtZQUNsRixJQUFJLENBQUMsbUJBQW1CLENBQUMscUJBQXFCLEVBQUUsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUM7U0FDOUU7YUFBTTtRQUNMLCtGQUErRjtRQUMvRixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsUUFBUSxDQUFDLHdEQUF3RCxDQUFDO1lBQ2xGLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLENBQUMsbURBQW1ELENBQUMsRUFBRTtZQUUvRSxNQUFNLENBQUMsR0FBRyxJQUFtQixDQUFBO1lBQzdCLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxxQkFBcUIsRUFBRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQztTQUUzRTtJQUNILENBQUM7Q0FFRjtBQS9CRCw4REErQkM7QUFFRCxTQUFnQixrQkFBa0IsQ0FBQyxLQUFnQjtJQUNqRCxPQUFPLEdBQUcsQ0FBQyxhQUFhLENBQUMscUJBQXFCLENBQzVDLEtBQUssRUFDTCxxQkFBcUIsRUFDckIsd0JBQXdCLENBQ3pCLENBQUM7QUFDSixDQUFDO0FBTkQsZ0RBTUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBd3MsIENmblJlc291cmNlLCBDdXN0b21SZXNvdXJjZSwgSUFzcGVjdCB9IGZyb20gXCJhd3MtY2RrLWxpYlwiO1xuaW1wb3J0IHsgQ2ZuUm9sZSwgUm9sZSB9IGZyb20gXCJhd3MtY2RrLWxpYi9hd3MtaWFtXCI7XG5pbXBvcnQgeyBDb25zdHJ1Y3QsIElDb25zdHJ1Y3QgfSBmcm9tIFwiY29uc3RydWN0c1wiO1xuXG5pbXBvcnQgaWFtID0gcmVxdWlyZSgnYXdzLWNkay1saWIvYXdzLWlhbScpO1xuXG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbnNCb3VuZGFyeUFzcGVjdCBpbXBsZW1lbnRzIElBc3BlY3Qge1xuXG4gIHJlYWRvbmx5IHBlcm1pc3Npb25zQm91bmRhcnlBcm46IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihyb2xlTmFtZT86IHN0cmluZykge1xuXG4gICAgaWYgKHJvbGVOYW1lKSB7XG4gICAgICB0aGlzLnBlcm1pc3Npb25zQm91bmRhcnlBcm4gPSBgYXJuOmF3czppYW06OiR7QXdzLkFDQ09VTlRfSUR9OnBvbGljeS8ke3JvbGVOYW1lfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGVybWlzc2lvbnNCb3VuZGFyeUFybiA9IGBhcm46YXdzOmlhbTo6JHtBd3MuQUNDT1VOVF9JRH06cG9saWN5L1JvbGVQZXJtaXNzaW9uQm91bmRhcnlgO1xuICAgIH1cbiAgfVxuXG4gIHZpc2l0KG5vZGU6IElDb25zdHJ1Y3QpOiB2b2lkIHtcblxuICAgIGlmIChub2RlIGluc3RhbmNlb2YgUm9sZSkge1xuICAgICAgY29uc3Qgcm9sZVJlc291cmNlID0gbm9kZS5ub2RlLmZpbmRDaGlsZChcIlJlc291cmNlXCIpIGFzIENmblJvbGU7XG4gICAgICByb2xlUmVzb3VyY2UuYWRkUHJvcGVydHlPdmVycmlkZShcIlBlcm1pc3Npb25zQm91bmRhcnlcIiwgdGhpcy5wZXJtaXNzaW9uc0JvdW5kYXJ5QXJuKTtcbiAgICB9IGlmIChDZm5SZXNvdXJjZS5pc0NmblJlc291cmNlKG5vZGUpICYmIG5vZGUuY2ZuUmVzb3VyY2VUeXBlID09PSAnQVdTOjpJQU06OlJvbGUnKSB7XG4gICAgICBub2RlLmFkZFByb3BlcnR5T3ZlcnJpZGUoJ1Blcm1pc3Npb25zQm91bmRhcnknLCB0aGlzLnBlcm1pc3Npb25zQm91bmRhcnlBcm4pO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyAgVGhpcyBpcyBzcGVjaWFsIGJ1ZyBmaXggYXMgVGhlc2UgYXJlIEN1c3RvbSBJQU06OlJvbGUgd2hpY2ggZG9udCBzdWNlZWQgdGhlIGFib3ZlIHN0YXRlbWVudFxuICAgICAgbm9kZS50b1N0cmluZygpLmluY2x1ZGVzKCdBV1NDREtPcGVuSWRDb25uZWN0UHJvdmlkZXJDdXN0b21SZXNvdXJjZVByb3ZpZGVyL1JvbGUnKSB8fFxuICAgICAgbm9kZS50b1N0cmluZygpLmluY2x1ZGVzKCdBV1NDREtDZm5VdGlsc1Byb3ZpZGVyQ3VzdG9tUmVzb3VyY2VQcm92aWRlci9Sb2xlJykpIHtcblxuICAgICAgY29uc3QgeCA9IG5vZGUgYXMgQ2ZuUmVzb3VyY2VcbiAgICAgIHguYWRkUHJvcGVydHlPdmVycmlkZShcIlBlcm1pc3Npb25zQm91bmRhcnlcIiwgdGhpcy5wZXJtaXNzaW9uc0JvdW5kYXJ5QXJuKTtcblxuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwZXJtaXNzaW9uQm91bmRhcnkoc2NvcGU6IENvbnN0cnVjdCkge1xuICByZXR1cm4gaWFtLk1hbmFnZWRQb2xpY3kuZnJvbU1hbmFnZWRQb2xpY3lOYW1lKFxuICAgIHNjb3BlLFxuICAgICdQZXJtaXNzaW9uc0JvdW5kYXJ5JyxcbiAgICAnUm9sZVBlcm1pc3Npb25Cb3VuZGFyeScsXG4gICk7XG59Il19
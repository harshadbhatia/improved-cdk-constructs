"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enableAWSLogServices = exports.createAWSLambdaARN = exports.configureLogCollection = exports.setupDatadogIntegration = void 0;
const client_secrets_manager_1 = require("@aws-sdk/client-secrets-manager");
const datadog_api_client_1 = require("@datadog/datadog-api-client");
const process_1 = require("process");
const API_KEY_SECRET = '/account/datadog/api-key';
const APP_KEY_SECRET = '/account/datadog/app-key';
const EXTERNAL_ID_SECRET = '/account/datadog/external-id';
async function setupDatadogIntegration(apiKey, appKey) {
    return await createAWSIntegration(apiKey, appKey)
        .then((externalId) => {
        if (externalId) {
            createExternalIDSecret(externalId);
            return externalId;
        }
        else {
            // Could be an update // we get external id
            const s = getSecretValue(EXTERNAL_ID_SECRET, `[Datadog] Unable to get secret at ${EXTERNAL_ID_SECRET}`);
            return s.then(v => {
                return JSON.parse(v).id;
            });
        }
    }).catch((err) => console.error("[Datadog] Unable to create AWS Integration", err));
}
exports.setupDatadogIntegration = setupDatadogIntegration;
async function createExternalIDSecret(externalId) {
    const client = getSecretManagerClient();
    const cmd = new client_secrets_manager_1.CreateSecretCommand({
        Name: EXTERNAL_ID_SECRET,
        Description: 'External ID associated with Datadog AWS Integration',
        SecretString: `{"id": "${externalId}"}`,
    });
    await client.send(cmd).then((data) => {
        console.log("[Datadog] External ID secret created");
        return 'OK';
    }).catch((err) => {
        // If the secret already exists, we update it
        const cm = new client_secrets_manager_1.UpdateSecretCommand({
            SecretId: EXTERNAL_ID_SECRET,
            Description: 'External ID associated with Datadog AWS Integration',
            SecretString: `{"id": "${externalId}"}`,
        });
        const c = getSecretManagerClient();
        c.send(cm).then((data) => {
            console.log("[Datadog] External ID secret updated");
            return 'OK';
        }).catch((err) => {
            console.error(`[Datadog] Unable to update secret at location /account/datadog/external-id`, err);
            (0, process_1.exit)(1);
        });
    });
}
function getSecretManagerClient() {
    const client = new client_secrets_manager_1.SecretsManagerClient({ region: process.env.CDK_DEFAULT_REGION });
    return client;
}
async function getAPIKey(apiKey, appKey) {
    const apiKeyVal = await getSecretValue(apiKey, `[Datadog] Unable to find secret ${apiKey}. Ensure only value is stored in secret`);
    const appKeyVal = await getSecretValue(appKey, `[Datadog] Unable to find secret ${appKey}. Ensure only value is stored in secret`);
    return [apiKeyVal, appKeyVal];
}
async function getSecretValue(secretId, errorString) {
    const client = getSecretManagerClient();
    const cmd = new client_secrets_manager_1.GetSecretValueCommand({ SecretId: secretId });
    return await client.send(cmd).then((data) => {
        return data.SecretString;
    });
}
function createAPIInstance(apiKey, appKey) {
    const configuration = datadog_api_client_1.client.createConfiguration({
        authMethods: {
            apiKeyAuth: apiKey,
            appKeyAuth: appKey
        }
    });
    const apiInstance = new datadog_api_client_1.v1.AWSIntegrationApi(configuration);
    return apiInstance;
}
async function createAWSIntegration(apiKey, appKey) {
    /**
     * Get all AWS tag filters returns "OK" response
     */
    return await getAPIKey(apiKey, appKey)
        .then(([apiKeyValue, appKeyValue]) => {
        console.log('[Datadog] Read secrets');
        const apiInstance = createAPIInstance(apiKeyValue, appKeyValue);
        return updateAWSAPIIntegration(apiInstance)
            .then((data) => {
            console.log("[Datadog] Updated account successfully");
            return;
        }).catch((error) => {
            console.log("[Datadog] Failed to update configuration, trying to create it instead");
            return createAWSAPIIntegration(apiInstance)
                .then((data) => { return data.externalId; })
                .catch((error) => { console.error(error); (0, process_1.exit)(1); });
        });
    }).catch((err) => {
        console.error("[Datadog] Failed to get APP Key", err);
        (0, process_1.exit)(1);
    });
}
function createAWSAPIIntegration(apiInstance) {
    const params = {
        body: {
            accountId: process.env.CDK_DEFAULT_ACCOUNT,
            filterTags: [`account_name:${process.env.ACCOUNT_NAME}`],
            hostTags: [`account_name:${process.env.ACCOUNT_NAME}`],
            metricsCollectionEnabled: true,
            resourceCollectionEnabled: true,
            cspmResourceCollectionEnabled: true,
            // excludedRegions: ["us-east-1", "us-west-2"],
            roleName: "DatadogAWSIntegrationRole",
            accountSpecificNamespaceRules: {
                lambda: true
            }
        },
    };
    return apiInstance
        .createAWSAccount(params);
}
async function updateAWSAPIIntegration(apiInstance) {
    const params = {
        body: {
            accountId: process.env.CDK_DEFAULT_ACCOUNT,
            filterTags: [`account_name:${process.env.ACCOUNT_NAME}`],
            hostTags: [`account_name:${process.env.ACCOUNT_NAME}`],
            metricsCollectionEnabled: true,
            resourceCollectionEnabled: true,
        },
        accountId: process.env.CDK_DEFAULT_ACCOUNT,
        roleName: "DatadogAWSIntegrationRole",
    };
    return await apiInstance
        .updateAWSAccount(params);
}
// Deprecated ?
async function configureLogCollection(lambdaArn, services, secretKey) {
    // const secret = await getAPIKey(API_KEY_SECRET, APP_KEY_SECRET)
    const configuration = datadog_api_client_1.client.createConfiguration({
        authMethods: {
            apiKeyAuth: API_KEY_SECRET,
            appKeyAuth: APP_KEY_SECRET
        }
    });
    // This is created after integration is created, along with forwarder stack.
    await createAWSLambdaARN(new datadog_api_client_1.v1.AWSLogsIntegrationApi(configuration), lambdaArn);
    await enableAWSLogServices(new datadog_api_client_1.v1.AWSLogsIntegrationApi(configuration), services);
}
exports.configureLogCollection = configureLogCollection;
async function createAWSLambdaARN(apiInstance, lambdaArn) {
    const params = {
        body: {
            accountId: process.env.CDK_DEFAULT_ACCOUNT,
            lambdaArn: lambdaArn,
        },
    };
    await apiInstance
        .createAWSLambdaARN(params)
        .then((data) => console.log("[Datadog] Lambda Integration for logs created"))
        .catch((error) => {
        console.error(error);
        (0, process_1.exit)(1);
    });
}
exports.createAWSLambdaARN = createAWSLambdaARN;
async function enableAWSLogServices(apiInstance, services = ["lambda"]) {
    const params = {
        body: {
            accountId: process.env.CDK_DEFAULT_ACCOUNT,
            services: services
        },
    };
    await apiInstance
        .enableAWSLogServices(params)
        .then((data) => console.log(`[Datadog] Enabled services for ${services}`))
        .catch((error) => { console.error(error); (0, process_1.exit)(1); });
}
exports.enableAWSLogServices = enableAWSLogServices;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V0dXAtaW50ZWdyYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzZXR1cC1pbnRlZ3JhdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw0RUFBd0k7QUFDeEksb0VBQXlEO0FBQ3pELHFDQUErQjtBQUUvQixNQUFNLGNBQWMsR0FBRywwQkFBMEIsQ0FBQTtBQUNqRCxNQUFNLGNBQWMsR0FBRywwQkFBMEIsQ0FBQTtBQUNqRCxNQUFNLGtCQUFrQixHQUFHLDhCQUE4QixDQUFBO0FBR2xELEtBQUssVUFBVSx1QkFBdUIsQ0FBQyxNQUFjLEVBQUUsTUFBYztJQUN4RSxPQUFPLE1BQU0sb0JBQW9CLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztTQUM1QyxJQUFJLENBQUMsQ0FBQyxVQUFVLEVBQUUsRUFBRTtRQUNqQixJQUFJLFVBQVUsRUFBRTtZQUNaLHNCQUFzQixDQUFDLFVBQVUsQ0FBQyxDQUFBO1lBQ2xDLE9BQU8sVUFBVSxDQUFBO1NBQ3BCO2FBQU07WUFDSCwyQ0FBMkM7WUFDM0MsTUFBTSxDQUFDLEdBQUcsY0FBYyxDQUFDLGtCQUFrQixFQUFFLHFDQUFxQyxrQkFBa0IsRUFBRSxDQUFDLENBQUE7WUFDdkcsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNkLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUE7WUFDM0IsQ0FBQyxDQUFDLENBQUE7U0FDTDtJQUVMLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyw0Q0FBNEMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFBO0FBQzNGLENBQUM7QUFmRCwwREFlQztBQUdELEtBQUssVUFBVSxzQkFBc0IsQ0FBQyxVQUFrQjtJQUNwRCxNQUFNLE1BQU0sR0FBRyxzQkFBc0IsRUFBRSxDQUFBO0lBQ3ZDLE1BQU0sR0FBRyxH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R0FBRyxDQUFDLG1CQUFvQjtZQUMzQyxRQUFRLEVBQUUsUUFBUTtTQUNyQjtLQUNKLENBQUM7SUFFRixNQUFNLFdBQVc7U0FDWixvQkFBb0IsQ0FBQyxNQUFNLENBQUM7U0FDNUIsSUFBSSxDQUFDLENBQUMsSUFBUyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLGtDQUFrQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1NBQzlFLEtBQUssQ0FBQyxDQUFDLEtBQVUsRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUEsY0FBSSxFQUFDLENBQUMsQ0FBQyxDQUFBLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEUsQ0FBQztBQWJELG9EQWFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ3JlYXRlU2VjcmV0Q29tbWFuZCwgR2V0U2VjcmV0VmFsdWVDb21tYW5kLCBTZWNyZXRzTWFuYWdlckNsaWVudCwgVXBkYXRlU2VjcmV0Q29tbWFuZCB9IGZyb20gXCJAYXdzLXNkay9jbGllbnQtc2VjcmV0cy1tYW5hZ2VyXCI7XG5pbXBvcnQgeyBjbGllbnQsIHYxIH0gZnJvbSBcIkBkYXRhZG9nL2RhdGFkb2ctYXBpLWNsaWVudFwiO1xuaW1wb3J0IHsgZXhpdCB9IGZyb20gXCJwcm9jZXNzXCI7XG5cbmNvbnN0IEFQSV9LRVlfU0VDUkVUID0gJy9hY2NvdW50L2RhdGFkb2cvYXBpLWtleSdcbmNvbnN0IEFQUF9LRVlfU0VDUkVUID0gJy9hY2NvdW50L2RhdGFkb2cvYXBwLWtleSdcbmNvbnN0IEVYVEVSTkFMX0lEX1NFQ1JFVCA9ICcvYWNjb3VudC9kYXRhZG9nL2V4dGVybmFsLWlkJ1xuXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXR1cERhdGFkb2dJbnRlZ3JhdGlvbihhcGlLZXk6IHN0cmluZywgYXBwS2V5OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYXdhaXQgY3JlYXRlQVdTSW50ZWdyYXRpb24oYXBpS2V5LCBhcHBLZXkpXG4gICAgICAgIC50aGVuKChleHRlcm5hbElkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXh0ZXJuYWxJZCkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUV4dGVybmFsSURTZWNyZXQoZXh0ZXJuYWxJZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZXJuYWxJZFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDb3VsZCBiZSBhbiB1cGRhdGUgLy8gd2UgZ2V0IGV4dGVybmFsIGlkXG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGdldFNlY3JldFZhbHVlKEVYVEVSTkFMX0lEX1NFQ1JFVCwgYFtEYXRhZG9nXSBVbmFibGUgdG8gZ2V0IHNlY3JldCBhdCAke0VYVEVSTkFMX0lEX1NFQ1JFVH1gKVxuICAgICAgICAgICAgICAgIHJldHVybiBzLnRoZW4odiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHYpLmlkXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiBjb25zb2xlLmVycm9yKFwiW0RhdGFkb2ddIFVuYWJsZSB0byBjcmVhdGUgQVdTIEludGVncmF0aW9uXCIsIGVycikpXG59XG5cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlRXh0ZXJuYWxJRFNlY3JldChleHRlcm5hbElkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBjbGllbnQgPSBnZXRTZWNyZXRNYW5hZ2VyQ2xpZW50KClcbiAgICBjb25zdCBjbWQgPSBuZXcgQ3JlYXRlU2VjcmV0Q29tbWFuZCh7XG4gICAgICAgIE5hbWU6IEVYVEVSTkFMX0lEX1NFQ1JFVCxcbiAgICAgICAgRGVzY3JpcHRpb246ICdFeHRlcm5hbCBJRCBhc3NvY2lhdGVkIHdpdGggRGF0YWRvZyBBV1MgSW50ZWdyYXRpb24nLFxuICAgICAgICBTZWNyZXRTdHJpbmc6IGB7XCJpZFwiOiBcIiR7ZXh0ZXJuYWxJZH1cIn1gLFxuICAgIH0pO1xuXG4gICAgYXdhaXQgY2xpZW50LnNlbmQoY21kKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0RhdGFkb2ddIEV4dGVybmFsIElEIHNlY3JldCBjcmVhdGVkXCIpXG4gICAgICAgIHJldHVybiAnT0snXG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAvLyBJZiB0aGUgc2VjcmV0IGFscmVhZHkgZXhpc3RzLCB3ZSB1cGRhdGUgaXRcbiAgICAgICAgY29uc3QgY20gPSBuZXcgVXBkYXRlU2VjcmV0Q29tbWFuZCh7XG4gICAgICAgICAgICBTZWNyZXRJZDogRVhURVJOQUxfSURfU0VDUkVULFxuICAgICAgICAgICAgRGVzY3JpcHRpb246ICdFeHRlcm5hbCBJRCBhc3NvY2lhdGVkIHdpdGggRGF0YWRvZyBBV1MgSW50ZWdyYXRpb24nLFxuICAgICAgICAgICAgU2VjcmV0U3RyaW5nOiBge1wiaWRcIjogXCIke2V4dGVybmFsSWR9XCJ9YCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGMgPSBnZXRTZWNyZXRNYW5hZ2VyQ2xpZW50KClcbiAgICAgICAgYy5zZW5kKGNtKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltEYXRhZG9nXSBFeHRlcm5hbCBJRCBzZWNyZXQgdXBkYXRlZFwiKVxuICAgICAgICAgICAgcmV0dXJuICdPSydcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW0RhdGFkb2ddIFVuYWJsZSB0byB1cGRhdGUgc2VjcmV0IGF0IGxvY2F0aW9uIC9hY2NvdW50L2RhdGFkb2cvZXh0ZXJuYWwtaWRgLCBlcnIpXG4gICAgICAgICAgICBleGl0KDEpXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG59XG5cbmZ1bmN0aW9uIGdldFNlY3JldE1hbmFnZXJDbGllbnQoKTogU2VjcmV0c01hbmFnZXJDbGllbnQge1xuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBTZWNyZXRzTWFuYWdlckNsaWVudCh7IHJlZ2lvbjogcHJvY2Vzcy5lbnYuQ0RLX0RFRkFVTFRfUkVHSU9OIH0pXG4gICAgcmV0dXJuIGNsaWVudFxufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRBUElLZXkoYXBpS2V5OiBzdHJpbmcsIGFwcEtleTogc3RyaW5nKSB7XG4gICAgY29uc3QgYXBpS2V5VmFsID0gYXdhaXQgZ2V0U2VjcmV0VmFsdWUoXG4gICAgICAgIGFwaUtleSxcbiAgICAgICAgYFtEYXRhZG9nXSBVbmFibGUgdG8gZmluZCBzZWNyZXQgJHthcGlLZXl9LiBFbnN1cmUgb25seSB2YWx1ZSBpcyBzdG9yZWQgaW4gc2VjcmV0YFxuICAgIClcbiAgICBjb25zdCBhcHBLZXlWYWwgPSBhd2FpdCBnZXRTZWNyZXRWYWx1ZShcbiAgICAgICAgYXBwS2V5LFxuICAgICAgICBgW0RhdGFkb2ddIFVuYWJsZSB0byBmaW5kIHNlY3JldCAke2FwcEtleX0uIEVuc3VyZSBvbmx5IHZhbHVlIGlzIHN0b3JlZCBpbiBzZWNyZXRgXG4gICAgKVxuXG4gICAgcmV0dXJuIFthcGlLZXlWYWwsIGFwcEtleVZhbF1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0U2VjcmV0VmFsdWUoc2VjcmV0SWQ6IHN0cmluZywgZXJyb3JTdHJpbmc6IHN0cmluZykge1xuICAgIGNvbnN0IGNsaWVudCA9IGdldFNlY3JldE1hbmFnZXJDbGllbnQoKVxuICAgIGNvbnN0IGNtZCA9IG5ldyBHZXRTZWNyZXRWYWx1ZUNvbW1hbmQoeyBTZWNyZXRJZDogc2VjcmV0SWQgfSlcblxuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc2VuZChjbWQpLnRoZW4oKGRhdGE6IGFueSkgPT4ge1xuICAgICAgICByZXR1cm4gZGF0YS5TZWNyZXRTdHJpbmchXG4gICAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlQVBJSW5zdGFuY2UoYXBpS2V5OiBzdHJpbmcsIGFwcEtleTogc3RyaW5nKTogdjEuQVdTSW50ZWdyYXRpb25BcGkge1xuICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSBjbGllbnQuY3JlYXRlQ29uZmlndXJhdGlvbih7XG4gICAgICAgIGF1dGhNZXRob2RzOiB7XG4gICAgICAgICAgICBhcGlLZXlBdXRoOiBhcGlLZXksXG4gICAgICAgICAgICBhcHBLZXlBdXRoOiBhcHBLZXlcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGFwaUluc3RhbmNlID0gbmV3IHYxLkFXU0ludGVncmF0aW9uQXBpKGNvbmZpZ3VyYXRpb24pO1xuXG4gICAgcmV0dXJuIGFwaUluc3RhbmNlXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFXU0ludGVncmF0aW9uKGFwaUtleTogc3RyaW5nLCBhcHBLZXk6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBBV1MgdGFnIGZpbHRlcnMgcmV0dXJucyBcIk9LXCIgcmVzcG9uc2VcbiAgICAgKi9cblxuICAgIHJldHVybiBhd2FpdCBnZXRBUElLZXkoYXBpS2V5LCBhcHBLZXkpXG4gICAgICAgIC50aGVuKChbYXBpS2V5VmFsdWUsIGFwcEtleVZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tEYXRhZG9nXSBSZWFkIHNlY3JldHMnKVxuICAgICAgICAgICAgY29uc3QgYXBpSW5zdGFuY2UgPSBjcmVhdGVBUElJbnN0YW5jZShhcGlLZXlWYWx1ZSwgYXBwS2V5VmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlQVdTQVBJSW50ZWdyYXRpb24oYXBpSW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgLnRoZW4oKGRhdGE6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltEYXRhZG9nXSBVcGRhdGVkIGFjY291bnQgc3VjY2Vzc2Z1bGx5XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcjogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0RhdGFkb2ddIEZhaWxlZCB0byB1cGRhdGUgY29uZmlndXJhdGlvbiwgdHJ5aW5nIHRvIGNyZWF0ZSBpdCBpbnN0ZWFkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVBV1NBUElJbnRlZ3JhdGlvbihhcGlJbnN0YW5jZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChkYXRhOiB2MS5BV1NBY2NvdW50Q3JlYXRlUmVzcG9uc2UpID0+IHsgcmV0dXJuIGRhdGEuZXh0ZXJuYWxJZCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcjogYW55KSA9PiB7IGNvbnNvbGUuZXJyb3IoZXJyb3IpOyBleGl0KDEpIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbRGF0YWRvZ10gRmFpbGVkIHRvIGdldCBBUFAgS2V5XCIsIGVycilcbiAgICAgICAgICAgIGV4aXQoMSlcbiAgICAgICAgfSlcblxufVxuXG5mdW5jdGlvbiBjcmVhdGVBV1NBUElJbnRlZ3JhdGlvbihhcGlJbnN0YW5jZTogdjEuQVdTSW50ZWdyYXRpb25BcGkpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHBhcmFtczogdjEuQVdTSW50ZWdyYXRpb25BcGlDcmVhdGVBV1NBY2NvdW50UmVxdWVzdCA9IHtcbiAgICAgICAgYm9keToge1xuICAgICAgICAgICAgYWNjb3VudElkOiBwcm9jZXNzLmVudi5DREtfREVGQVVMVF9BQ0NPVU5UISxcbiAgICAgICAgICAgIGZpbHRlclRhZ3M6IFtgYWNjb3VudF9uYW1lOiR7cHJvY2Vzcy5lbnYuQUNDT1VOVF9OQU1FfWBdLFxuICAgICAgICAgICAgaG9zdFRhZ3M6IFtgYWNjb3VudF9uYW1lOiR7cHJvY2Vzcy5lbnYuQUNDT1VOVF9OQU1FfWBdLFxuICAgICAgICAgICAgbWV0cmljc0NvbGxlY3Rpb25FbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgcmVzb3VyY2VDb2xsZWN0aW9uRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIGNzcG1SZXNvdXJjZUNvbGxlY3Rpb25FbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgLy8gZXhjbHVkZWRSZWdpb25zOiBbXCJ1cy1lYXN0LTFcIiwgXCJ1cy13ZXN0LTJcIl0sXG4gICAgICAgICAgICByb2xlTmFtZTogXCJEYXRhZG9nQVdTSW50ZWdyYXRpb25Sb2xlXCIsXG4gICAgICAgICAgICBhY2NvdW50U3BlY2lmaWNOYW1lc3BhY2VSdWxlczoge1xuICAgICAgICAgICAgICAgIGxhbWJkYTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG5cbiAgICByZXR1cm4gYXBpSW5zdGFuY2VcbiAgICAgICAgLmNyZWF0ZUFXU0FjY291bnQocGFyYW1zKVxuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUFXU0FQSUludGVncmF0aW9uKGFwaUluc3RhbmNlOiB2MS5BV1NJbnRlZ3JhdGlvbkFwaSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcGFyYW1zOiB2MS5BV1NJbnRlZ3JhdGlvbkFwaVVwZGF0ZUFXU0FjY291bnRSZXF1ZXN0ID0ge1xuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBhY2NvdW50SWQ6IHByb2Nlc3MuZW52LkNES19ERUZBVUxUX0FDQ09VTlQhLFxuICAgICAgICAgICAgZmlsdGVyVGFnczogW2BhY2NvdW50X25hbWU6JHtwcm9jZXNzLmVudi5BQ0NPVU5UX05BTUV9YF0sXG4gICAgICAgICAgICBob3N0VGFnczogW2BhY2NvdW50X25hbWU6JHtwcm9jZXNzLmVudi5BQ0NPVU5UX05BTUV9YF0sXG4gICAgICAgICAgICBtZXRyaWNzQ29sbGVjdGlvbkVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICByZXNvdXJjZUNvbGxlY3Rpb25FbmFibGVkOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBhY2NvdW50SWQ6IHByb2Nlc3MuZW52LkNES19ERUZBVUxUX0FDQ09VTlQhLFxuICAgICAgICByb2xlTmFtZTogXCJEYXRhZG9nQVdTSW50ZWdyYXRpb25Sb2xlXCIsXG4gICAgfTtcblxuICAgIHJldHVybiBhd2FpdCBhcGlJbnN0YW5jZVxuICAgICAgICAudXBkYXRlQVdTQWNjb3VudChwYXJhbXMpXG59XG5cbi8vIERlcHJlY2F0ZWQgP1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbmZpZ3VyZUxvZ0NvbGxlY3Rpb24obGFtYmRhQXJuOiBzdHJpbmcsIHNlcnZpY2VzPzogc3RyaW5nW10sIHNlY3JldEtleT86IHN0cmluZykge1xuICAgIC8vIGNvbnN0IHNlY3JldCA9IGF3YWl0IGdldEFQSUtleShBUElfS0VZX1NFQ1JFVCwgQVBQX0tFWV9TRUNSRVQpXG4gICAgY29uc3QgY29uZmlndXJhdGlvbiA9IGNsaWVudC5jcmVhdGVDb25maWd1cmF0aW9uKHtcbiAgICAgICAgYXV0aE1ldGhvZHM6IHtcbiAgICAgICAgICAgIGFwaUtleUF1dGg6IEFQSV9LRVlfU0VDUkVULFxuICAgICAgICAgICAgYXBwS2V5QXV0aDogQVBQX0tFWV9TRUNSRVRcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFRoaXMgaXMgY3JlYXRlZCBhZnRlciBpbnRlZ3JhdGlvbiBpcyBjcmVhdGVkLCBhbG9uZyB3aXRoIGZvcndhcmRlciBzdGFjay5cblxuICAgIGF3YWl0IGNyZWF0ZUFXU0xhbWJkYUFSTihuZXcgdjEuQVdTTG9nc0ludGVncmF0aW9uQXBpKGNvbmZpZ3VyYXRpb24pLCBsYW1iZGFBcm4pXG4gICAgYXdhaXQgZW5hYmxlQVdTTG9nU2VydmljZXMobmV3IHYxLkFXU0xvZ3NJbnRlZ3JhdGlvbkFwaShjb25maWd1cmF0aW9uKSwgc2VydmljZXMpXG5cblxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQVdTTGFtYmRhQVJOKGFwaUluc3RhbmNlOiB2MS5BV1NMb2dzSW50ZWdyYXRpb25BcGksIGxhbWJkYUFybjogc3RyaW5nKSB7XG5cbiAgICBjb25zdCBwYXJhbXM6IHYxLkFXU0xvZ3NJbnRlZ3JhdGlvbkFwaUNyZWF0ZUFXU0xhbWJkYUFSTlJlcXVlc3QgPSB7XG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGFjY291bnRJZDogcHJvY2Vzcy5lbnYuQ0RLX0RFRkFVTFRfQUNDT1VOVCEsXG4gICAgICAgICAgICBsYW1iZGFBcm46IGxhbWJkYUFybixcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgYXdhaXQgYXBpSW5zdGFuY2VcbiAgICAgICAgLmNyZWF0ZUFXU0xhbWJkYUFSTihwYXJhbXMpXG4gICAgICAgIC50aGVuKChkYXRhOiBhbnkpID0+IGNvbnNvbGUubG9nKFwiW0RhdGFkb2ddIExhbWJkYSBJbnRlZ3JhdGlvbiBmb3IgbG9ncyBjcmVhdGVkXCIpKVxuICAgICAgICAuY2F0Y2goKGVycm9yOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gICAgICAgICAgICBleGl0KDEpXG4gICAgICAgIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5hYmxlQVdTTG9nU2VydmljZXMoYXBpSW5zdGFuY2U6IHYxLkFXU0xvZ3NJbnRlZ3JhdGlvbkFwaSwgc2VydmljZXMgPSBbXCJsYW1iZGFcIl0pIHtcblxuICAgIGNvbnN0IHBhcmFtczogdjEuQVdTTG9nc0ludGVncmF0aW9uQXBpRW5hYmxlQVdTTG9nU2VydmljZXNSZXF1ZXN0ID0ge1xuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBhY2NvdW50SWQ6IHByb2Nlc3MuZW52LkNES19ERUZBVUxUX0FDQ09VTlQhLFxuICAgICAgICAgICAgc2VydmljZXM6IHNlcnZpY2VzXG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIGF3YWl0IGFwaUluc3RhbmNlXG4gICAgICAgIC5lbmFibGVBV1NMb2dTZXJ2aWNlcyhwYXJhbXMpXG4gICAgICAgIC50aGVuKChkYXRhOiBhbnkpID0+IGNvbnNvbGUubG9nKGBbRGF0YWRvZ10gRW5hYmxlZCBzZXJ2aWNlcyBmb3IgJHtzZXJ2aWNlc31gKSlcbiAgICAgICAgLmNhdGNoKChlcnJvcjogYW55KSA9PiB7IGNvbnNvbGUuZXJyb3IoZXJyb3IpOyBleGl0KDEpIH0pO1xufVxuIl19
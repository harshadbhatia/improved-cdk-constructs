"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enableAWSLogServices = exports.createAWSLambdaARN = exports.configureLogCollection = exports.setupDatadogIntegration = void 0;
const client_secrets_manager_1 = require("@aws-sdk/client-secrets-manager");
const datadog_api_client_1 = require("@datadog/datadog-api-client");
const process_1 = require("process");
const API_KEY_SECRET = '/account/datadog/api-key';
const APP_KEY_SECRET = '/account/datadog/app-key';
const EXTERNAL_ID_SECRET = '/account/datadog/external-id';
async function setupDatadogIntegration(apiKey, appKey) {
    return await createAWSIntegration(apiKey, appKey)
        .then((externalId) => {
        if (externalId) {
            createExternalIDSecret(externalId);
            return externalId;
        }
        else {
            // Could be an update // we get external id
            const s = getSecretValue(EXTERNAL_ID_SECRET, `[Datadog] Unable to get secret at ${EXTERNAL_ID_SECRET}`);
            return s;
        }
    }).catch((err) => console.error("[Datadog] Unable to create AWS Integration", err));
}
exports.setupDatadogIntegration = setupDatadogIntegration;
async function createExternalIDSecret(externalId) {
    const client = getSecretManagerClient();
    const cmd = new client_secrets_manager_1.CreateSecretCommand({
        Name: EXTERNAL_ID_SECRET,
        Description: 'External ID associated with Datadog AWS Integration',
        SecretString: `{"id": "${externalId}"}`,
    });
    await client.send(cmd).then((data) => {
        console.log("[Datadog] External ID secret created");
        return 'OK';
    }).catch((err) => {
        // If the secret already exists, we update it
        const cm = new client_secrets_manager_1.UpdateSecretCommand({
            SecretId: EXTERNAL_ID_SECRET,
            Description: 'External ID associated with Datadog AWS Integration',
            SecretString: `{"id": "${externalId}"}`,
        });
        const c = getSecretManagerClient();
        c.send(cm).then((data) => {
            console.log("[Datadog] External ID secret updated");
            return 'OK';
        }).catch((err) => {
            console.error(`[Datadog] Unable to update secret at location /account/datadog/external-id`, err);
            (0, process_1.exit)(1);
        });
        console.error(`[Datadog] Unable to create secret at location /account/datadog/external-id`, err);
        (0, process_1.exit)(1);
    });
}
function getSecretManagerClient() {
    const client = new client_secrets_manager_1.SecretsManagerClient({ region: process.env.CDK_DEFAULT_REGION });
    return client;
}
async function getAPIKey(apiKey, appKey) {
    const apiKeyVal = await getSecretValue(apiKey, `[Datadog] Unable to find secret ${apiKey}. Ensure only value is stored in secret`);
    const appKeyVal = await getSecretValue(appKey, `[Datadog] Unable to find secret ${appKey}. Ensure only value is stored in secret`);
    return [apiKeyVal, appKeyVal];
}
async function getSecretValue(secretId, errorString) {
    const client = getSecretManagerClient();
    const cmd = new client_secrets_manager_1.GetSecretValueCommand({ SecretId: secretId });
    return await client.send(cmd).then((data) => {
        return data.SecretString;
    });
}
function createAPIInstance(apiKey, appKey) {
    const configuration = datadog_api_client_1.client.createConfiguration({
        authMethods: {
            apiKeyAuth: apiKey,
            appKeyAuth: appKey
        }
    });
    const apiInstance = new datadog_api_client_1.v1.AWSIntegrationApi(configuration);
    return apiInstance;
}
async function createAWSIntegration(apiKey, appKey) {
    /**
     * Get all AWS tag filters returns "OK" response
     */
    return await getAPIKey(apiKey, appKey)
        .then(([apiKeyValue, appKeyValue]) => {
        console.log('[Datadog] Read secrets');
        const apiInstance = createAPIInstance(apiKeyValue, appKeyValue);
        return updateAWSAPIIntegration(apiInstance)
            .then((data) => {
            console.log("[Datadog] Updated account successfully");
            return;
        }).catch((error) => {
            console.log("[Datadog] Failed to update configuration, trying to create it instead");
            return createAWSAPIIntegration(apiInstance)
                .then((data) => { return data.externalId; })
                .catch((error) => { console.error(error); (0, process_1.exit)(1); });
        });
    }).catch((err) => {
        console.error("[Datadog] Failed to get APP Key", err);
        (0, process_1.exit)(1);
    });
}
function createAWSAPIIntegration(apiInstance) {
    const params = {
        body: {
            accountId: process.env.CDK_DEFAULT_ACCOUNT,
            filterTags: [`account_name:${process.env.ACCOUNT_NAME}`],
            hostTags: [`account_name:${process.env.ACCOUNT_NAME}`],
            metricsCollectionEnabled: true,
            resourceCollectionEnabled: true,
            cspmResourceCollectionEnabled: true,
            // excludedRegions: ["us-east-1", "us-west-2"],
            roleName: "DatadogAWSIntegrationRole",
            accountSpecificNamespaceRules: {
                lambda: true
            }
        },
    };
    return apiInstance
        .createAWSAccount(params);
}
async function updateAWSAPIIntegration(apiInstance) {
    const params = {
        body: {
            accountId: process.env.CDK_DEFAULT_ACCOUNT,
            filterTags: [`account_name:${process.env.ACCOUNT_NAME}`],
            hostTags: [`account_name:${process.env.ACCOUNT_NAME}`],
            metricsCollectionEnabled: true,
            resourceCollectionEnabled: true,
        },
        accountId: process.env.CDK_DEFAULT_ACCOUNT,
        roleName: "DatadogAWSIntegrationRole",
    };
    return await apiInstance
        .updateAWSAccount(params);
}
// Deprecated ?
async function configureLogCollection(lambdaArn, services, secretKey) {
    // const secret = await getAPIKey(API_KEY_SECRET, APP_KEY_SECRET)
    const configuration = datadog_api_client_1.client.createConfiguration({
        authMethods: {
            apiKeyAuth: API_KEY_SECRET,
            appKeyAuth: APP_KEY_SECRET
        }
    });
    // This is created after integration is created, along with forwarder stack.
    await createAWSLambdaARN(new datadog_api_client_1.v1.AWSLogsIntegrationApi(configuration), lambdaArn);
    await enableAWSLogServices(new datadog_api_client_1.v1.AWSLogsIntegrationApi(configuration), services);
}
exports.configureLogCollection = configureLogCollection;
async function createAWSLambdaARN(apiInstance, lambdaArn) {
    const params = {
        body: {
            accountId: process.env.CDK_DEFAULT_ACCOUNT,
            lambdaArn: lambdaArn,
        },
    };
    await apiInstance
        .createAWSLambdaARN(params)
        .then((data) => console.log("[Datadog] Lambda Integration for logs created"))
        .catch((error) => {
        console.error(error);
        (0, process_1.exit)(1);
    });
}
exports.createAWSLambdaARN = createAWSLambdaARN;
async function enableAWSLogServices(apiInstance, services = ["lambda"]) {
    const params = {
        body: {
            accountId: process.env.CDK_DEFAULT_ACCOUNT,
            services: services
        },
    };
    await apiInstance
        .enableAWSLogServices(params)
        .then((data) => console.log(`[Datadog] Enabled services for ${services}`))
        .catch((error) => { console.error(error); (0, process_1.exit)(1); });
}
exports.enableAWSLogServices = enableAWSLogServices;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V0dXAtaW50ZWdyYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzZXR1cC1pbnRlZ3JhdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw0RUFBd0k7QUFDeEksb0VBQXlEO0FBQ3pELHFDQUErQjtBQUUvQixNQUFNLGNBQWMsR0FBRywwQkFBMEIsQ0FBQTtBQUNqRCxNQUFNLGNBQWMsR0FBRywwQkFBMEIsQ0FBQTtBQUNqRCxNQUFNLGtCQUFrQixHQUFHLDhCQUE4QixDQUFBO0FBR2xELEtBQUssVUFBVSx1QkFBdUIsQ0FBQyxNQUFjLEVBQUUsTUFBYztJQUN4RSxPQUFPLE1BQU0sb0JBQW9CLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztTQUM1QyxJQUFJLENBQUMsQ0FBQyxVQUFVLEVBQUUsRUFBRTtRQUNqQixJQUFJLFVBQVUsRUFBRTtZQUNaLHNCQUFzQixDQUFDLFVBQVUsQ0FBQyxDQUFBO1lBQ2xDLE9BQU8sVUFBVSxDQUFBO1NBQ3BCO2FBQU07WUFDSCwyQ0FBMkM7WUFDM0MsTUFBTSxDQUFDLEdBQUcsY0FBYyxDQUFDLGtCQUFrQixFQUFFLHFDQUFxQyxrQkFBa0IsRUFBRSxDQUFDLENBQUE7WUFDdkcsT0FBTyxDQUFDLENBQUE7U0FDWDtJQUVMLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyw0Q0FBNEMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFBO0FBRzNGLENBQUM7QUFmRCwwREFlQztBQUdELEtBQUssVUFBVSxzQkFBc0IsQ0FBQyxVQUFrQjtJQUNwRCxNQUFNLE1BQU0sR0FBRyxzQkFBc0IsRUFBRSxDQUFBO0lBQ3ZDLE1BQU0sR0FBRyxHQUFHLElBQUksNENBQW1CLENBQUM7UUFDaEMsSUFBSSxFQUFFLGtCQUFrQjtRQUN4QixXQUFXLEVBQUUscURBQXFEO1FBQ2xFLFlBQVksRUFBRSxXQUFXLFVBQVUsSUFBSTtLQUMx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b0I7WUFDM0MsUUFBUSxFQUFFLFFBQVE7U0FDckI7S0FDSixDQUFDO0lBRUYsTUFBTSxXQUFXO1NBQ1osb0JBQW9CLENBQUMsTUFBTSxDQUFDO1NBQzVCLElBQUksQ0FBQyxDQUFDLElBQVMsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxrQ0FBa0MsUUFBUSxFQUFFLENBQUMsQ0FBQztTQUM5RSxLQUFLLENBQUMsQ0FBQyxLQUFVLEVBQUUsRUFBRSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFBLGNBQUksRUFBQyxDQUFDLENBQUMsQ0FBQSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xFLENBQUM7QUFiRCxvREFhQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENyZWF0ZVNlY3JldENvbW1hbmQsIEdldFNlY3JldFZhbHVlQ29tbWFuZCwgU2VjcmV0c01hbmFnZXJDbGllbnQsIFVwZGF0ZVNlY3JldENvbW1hbmQgfSBmcm9tIFwiQGF3cy1zZGsvY2xpZW50LXNlY3JldHMtbWFuYWdlclwiO1xuaW1wb3J0IHsgY2xpZW50LCB2MSB9IGZyb20gXCJAZGF0YWRvZy9kYXRhZG9nLWFwaS1jbGllbnRcIjtcbmltcG9ydCB7IGV4aXQgfSBmcm9tIFwicHJvY2Vzc1wiO1xuXG5jb25zdCBBUElfS0VZX1NFQ1JFVCA9ICcvYWNjb3VudC9kYXRhZG9nL2FwaS1rZXknXG5jb25zdCBBUFBfS0VZX1NFQ1JFVCA9ICcvYWNjb3VudC9kYXRhZG9nL2FwcC1rZXknXG5jb25zdCBFWFRFUk5BTF9JRF9TRUNSRVQgPSAnL2FjY291bnQvZGF0YWRvZy9leHRlcm5hbC1pZCdcblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0dXBEYXRhZG9nSW50ZWdyYXRpb24oYXBpS2V5OiBzdHJpbmcsIGFwcEtleTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGF3YWl0IGNyZWF0ZUFXU0ludGVncmF0aW9uKGFwaUtleSwgYXBwS2V5KVxuICAgICAgICAudGhlbigoZXh0ZXJuYWxJZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV4dGVybmFsSWQpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVFeHRlcm5hbElEU2VjcmV0KGV4dGVybmFsSWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVybmFsSWRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ291bGQgYmUgYW4gdXBkYXRlIC8vIHdlIGdldCBleHRlcm5hbCBpZFxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBnZXRTZWNyZXRWYWx1ZShFWFRFUk5BTF9JRF9TRUNSRVQsIGBbRGF0YWRvZ10gVW5hYmxlIHRvIGdldCBzZWNyZXQgYXQgJHtFWFRFUk5BTF9JRF9TRUNSRVR9YClcbiAgICAgICAgICAgICAgICByZXR1cm4gc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IGNvbnNvbGUuZXJyb3IoXCJbRGF0YWRvZ10gVW5hYmxlIHRvIGNyZWF0ZSBBV1MgSW50ZWdyYXRpb25cIiwgZXJyKSlcblxuXG59XG5cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlRXh0ZXJuYWxJRFNlY3JldChleHRlcm5hbElkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBjbGllbnQgPSBnZXRTZWNyZXRNYW5hZ2VyQ2xpZW50KClcbiAgICBjb25zdCBjbWQgPSBuZXcgQ3JlYXRlU2VjcmV0Q29tbWFuZCh7XG4gICAgICAgIE5hbWU6IEVYVEVSTkFMX0lEX1NFQ1JFVCxcbiAgICAgICAgRGVzY3JpcHRpb246ICdFeHRlcm5hbCBJRCBhc3NvY2lhdGVkIHdpdGggRGF0YWRvZyBBV1MgSW50ZWdyYXRpb24nLFxuICAgICAgICBTZWNyZXRTdHJpbmc6IGB7XCJpZFwiOiBcIiR7ZXh0ZXJuYWxJZH1cIn1gLFxuICAgIH0pO1xuXG4gICAgYXdhaXQgY2xpZW50LnNlbmQoY21kKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0RhdGFkb2ddIEV4dGVybmFsIElEIHNlY3JldCBjcmVhdGVkXCIpXG4gICAgICAgIHJldHVybiAnT0snXG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAvLyBJZiB0aGUgc2VjcmV0IGFscmVhZHkgZXhpc3RzLCB3ZSB1cGRhdGUgaXRcbiAgICAgICAgY29uc3QgY20gPSBuZXcgVXBkYXRlU2VjcmV0Q29tbWFuZCh7XG4gICAgICAgICAgICBTZWNyZXRJZDogRVhURVJOQUxfSURfU0VDUkVULFxuICAgICAgICAgICAgRGVzY3JpcHRpb246ICdFeHRlcm5hbCBJRCBhc3NvY2lhdGVkIHdpdGggRGF0YWRvZyBBV1MgSW50ZWdyYXRpb24nLFxuICAgICAgICAgICAgU2VjcmV0U3RyaW5nOiBge1wiaWRcIjogXCIke2V4dGVybmFsSWR9XCJ9YCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGMgPSBnZXRTZWNyZXRNYW5hZ2VyQ2xpZW50KClcbiAgICAgICAgYy5zZW5kKGNtKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltEYXRhZG9nXSBFeHRlcm5hbCBJRCBzZWNyZXQgdXBkYXRlZFwiKVxuICAgICAgICAgICAgcmV0dXJuICdPSydcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW0RhdGFkb2ddIFVuYWJsZSB0byB1cGRhdGUgc2VjcmV0IGF0IGxvY2F0aW9uIC9hY2NvdW50L2RhdGFkb2cvZXh0ZXJuYWwtaWRgLCBlcnIpXG4gICAgICAgICAgICBleGl0KDEpXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbRGF0YWRvZ10gVW5hYmxlIHRvIGNyZWF0ZSBzZWNyZXQgYXQgbG9jYXRpb24gL2FjY291bnQvZGF0YWRvZy9leHRlcm5hbC1pZGAsIGVycilcbiAgICAgICAgZXhpdCgxKVxuICAgIH0pO1xuXG59XG5cbmZ1bmN0aW9uIGdldFNlY3JldE1hbmFnZXJDbGllbnQoKTogU2VjcmV0c01hbmFnZXJDbGllbnQge1xuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBTZWNyZXRzTWFuYWdlckNsaWVudCh7IHJlZ2lvbjogcHJvY2Vzcy5lbnYuQ0RLX0RFRkFVTFRfUkVHSU9OIH0pXG4gICAgcmV0dXJuIGNsaWVudFxufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRBUElLZXkoYXBpS2V5OiBzdHJpbmcsIGFwcEtleTogc3RyaW5nKSB7XG4gICAgY29uc3QgYXBpS2V5VmFsID0gYXdhaXQgZ2V0U2VjcmV0VmFsdWUoXG4gICAgICAgIGFwaUtleSxcbiAgICAgICAgYFtEYXRhZG9nXSBVbmFibGUgdG8gZmluZCBzZWNyZXQgJHthcGlLZXl9LiBFbnN1cmUgb25seSB2YWx1ZSBpcyBzdG9yZWQgaW4gc2VjcmV0YFxuICAgIClcbiAgICBjb25zdCBhcHBLZXlWYWwgPSBhd2FpdCBnZXRTZWNyZXRWYWx1ZShcbiAgICAgICAgYXBwS2V5LFxuICAgICAgICBgW0RhdGFkb2ddIFVuYWJsZSB0byBmaW5kIHNlY3JldCAke2FwcEtleX0uIEVuc3VyZSBvbmx5IHZhbHVlIGlzIHN0b3JlZCBpbiBzZWNyZXRgXG4gICAgKVxuXG4gICAgcmV0dXJuIFthcGlLZXlWYWwsIGFwcEtleVZhbF1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0U2VjcmV0VmFsdWUoc2VjcmV0SWQ6IHN0cmluZywgZXJyb3JTdHJpbmc6IHN0cmluZykge1xuICAgIGNvbnN0IGNsaWVudCA9IGdldFNlY3JldE1hbmFnZXJDbGllbnQoKVxuICAgIGNvbnN0IGNtZCA9IG5ldyBHZXRTZWNyZXRWYWx1ZUNvbW1hbmQoeyBTZWNyZXRJZDogc2VjcmV0SWQgfSlcblxuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc2VuZChjbWQpLnRoZW4oKGRhdGE6IGFueSkgPT4ge1xuICAgICAgICByZXR1cm4gZGF0YS5TZWNyZXRTdHJpbmchXG4gICAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlQVBJSW5zdGFuY2UoYXBpS2V5OiBzdHJpbmcsIGFwcEtleTogc3RyaW5nKTogdjEuQVdTSW50ZWdyYXRpb25BcGkge1xuICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSBjbGllbnQuY3JlYXRlQ29uZmlndXJhdGlvbih7XG4gICAgICAgIGF1dGhNZXRob2RzOiB7XG4gICAgICAgICAgICBhcGlLZXlBdXRoOiBhcGlLZXksXG4gICAgICAgICAgICBhcHBLZXlBdXRoOiBhcHBLZXlcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGFwaUluc3RhbmNlID0gbmV3IHYxLkFXU0ludGVncmF0aW9uQXBpKGNvbmZpZ3VyYXRpb24pO1xuXG4gICAgcmV0dXJuIGFwaUluc3RhbmNlXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFXU0ludGVncmF0aW9uKGFwaUtleTogc3RyaW5nLCBhcHBLZXk6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBBV1MgdGFnIGZpbHRlcnMgcmV0dXJucyBcIk9LXCIgcmVzcG9uc2VcbiAgICAgKi9cblxuICAgIHJldHVybiBhd2FpdCBnZXRBUElLZXkoYXBpS2V5LCBhcHBLZXkpXG4gICAgICAgIC50aGVuKChbYXBpS2V5VmFsdWUsIGFwcEtleVZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tEYXRhZG9nXSBSZWFkIHNlY3JldHMnKVxuICAgICAgICAgICAgY29uc3QgYXBpSW5zdGFuY2UgPSBjcmVhdGVBUElJbnN0YW5jZShhcGlLZXlWYWx1ZSwgYXBwS2V5VmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlQVdTQVBJSW50ZWdyYXRpb24oYXBpSW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgLnRoZW4oKGRhdGE6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltEYXRhZG9nXSBVcGRhdGVkIGFjY291bnQgc3VjY2Vzc2Z1bGx5XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcjogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0RhdGFkb2ddIEZhaWxlZCB0byB1cGRhdGUgY29uZmlndXJhdGlvbiwgdHJ5aW5nIHRvIGNyZWF0ZSBpdCBpbnN0ZWFkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVBV1NBUElJbnRlZ3JhdGlvbihhcGlJbnN0YW5jZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChkYXRhOiB2MS5BV1NBY2NvdW50Q3JlYXRlUmVzcG9uc2UpID0+IHsgcmV0dXJuIGRhdGEuZXh0ZXJuYWxJZCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcjogYW55KSA9PiB7IGNvbnNvbGUuZXJyb3IoZXJyb3IpOyBleGl0KDEpIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbRGF0YWRvZ10gRmFpbGVkIHRvIGdldCBBUFAgS2V5XCIsIGVycilcbiAgICAgICAgICAgIGV4aXQoMSlcbiAgICAgICAgfSlcblxufVxuXG5mdW5jdGlvbiBjcmVhdGVBV1NBUElJbnRlZ3JhdGlvbihhcGlJbnN0YW5jZTogdjEuQVdTSW50ZWdyYXRpb25BcGkpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHBhcmFtczogdjEuQVdTSW50ZWdyYXRpb25BcGlDcmVhdGVBV1NBY2NvdW50UmVxdWVzdCA9IHtcbiAgICAgICAgYm9keToge1xuICAgICAgICAgICAgYWNjb3VudElkOiBwcm9jZXNzLmVudi5DREtfREVGQVVMVF9BQ0NPVU5UISxcbiAgICAgICAgICAgIGZpbHRlclRhZ3M6IFtgYWNjb3VudF9uYW1lOiR7cHJvY2Vzcy5lbnYuQUNDT1VOVF9OQU1FfWBdLFxuICAgICAgICAgICAgaG9zdFRhZ3M6IFtgYWNjb3VudF9uYW1lOiR7cHJvY2Vzcy5lbnYuQUNDT1VOVF9OQU1FfWBdLFxuICAgICAgICAgICAgbWV0cmljc0NvbGxlY3Rpb25FbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgcmVzb3VyY2VDb2xsZWN0aW9uRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIGNzcG1SZXNvdXJjZUNvbGxlY3Rpb25FbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgLy8gZXhjbHVkZWRSZWdpb25zOiBbXCJ1cy1lYXN0LTFcIiwgXCJ1cy13ZXN0LTJcIl0sXG4gICAgICAgICAgICByb2xlTmFtZTogXCJEYXRhZG9nQVdTSW50ZWdyYXRpb25Sb2xlXCIsXG4gICAgICAgICAgICBhY2NvdW50U3BlY2lmaWNOYW1lc3BhY2VSdWxlczoge1xuICAgICAgICAgICAgICAgIGxhbWJkYTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG5cbiAgICByZXR1cm4gYXBpSW5zdGFuY2VcbiAgICAgICAgLmNyZWF0ZUFXU0FjY291bnQocGFyYW1zKVxuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUFXU0FQSUludGVncmF0aW9uKGFwaUluc3RhbmNlOiB2MS5BV1NJbnRlZ3JhdGlvbkFwaSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcGFyYW1zOiB2MS5BV1NJbnRlZ3JhdGlvbkFwaVVwZGF0ZUFXU0FjY291bnRSZXF1ZXN0ID0ge1xuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBhY2NvdW50SWQ6IHByb2Nlc3MuZW52LkNES19ERUZBVUxUX0FDQ09VTlQhLFxuICAgICAgICAgICAgZmlsdGVyVGFnczogW2BhY2NvdW50X25hbWU6JHtwcm9jZXNzLmVudi5BQ0NPVU5UX05BTUV9YF0sXG4gICAgICAgICAgICBob3N0VGFnczogW2BhY2NvdW50X25hbWU6JHtwcm9jZXNzLmVudi5BQ0NPVU5UX05BTUV9YF0sXG4gICAgICAgICAgICBtZXRyaWNzQ29sbGVjdGlvbkVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICByZXNvdXJjZUNvbGxlY3Rpb25FbmFibGVkOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBhY2NvdW50SWQ6IHByb2Nlc3MuZW52LkNES19ERUZBVUxUX0FDQ09VTlQhLFxuICAgICAgICByb2xlTmFtZTogXCJEYXRhZG9nQVdTSW50ZWdyYXRpb25Sb2xlXCIsXG4gICAgfTtcblxuICAgIHJldHVybiBhd2FpdCBhcGlJbnN0YW5jZVxuICAgICAgICAudXBkYXRlQVdTQWNjb3VudChwYXJhbXMpXG59XG5cbi8vIERlcHJlY2F0ZWQgP1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbmZpZ3VyZUxvZ0NvbGxlY3Rpb24obGFtYmRhQXJuOiBzdHJpbmcsIHNlcnZpY2VzPzogc3RyaW5nW10sIHNlY3JldEtleT86IHN0cmluZykge1xuICAgIC8vIGNvbnN0IHNlY3JldCA9IGF3YWl0IGdldEFQSUtleShBUElfS0VZX1NFQ1JFVCwgQVBQX0tFWV9TRUNSRVQpXG4gICAgY29uc3QgY29uZmlndXJhdGlvbiA9IGNsaWVudC5jcmVhdGVDb25maWd1cmF0aW9uKHtcbiAgICAgICAgYXV0aE1ldGhvZHM6IHtcbiAgICAgICAgICAgIGFwaUtleUF1dGg6IEFQSV9LRVlfU0VDUkVULFxuICAgICAgICAgICAgYXBwS2V5QXV0aDogQVBQX0tFWV9TRUNSRVRcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFRoaXMgaXMgY3JlYXRlZCBhZnRlciBpbnRlZ3JhdGlvbiBpcyBjcmVhdGVkLCBhbG9uZyB3aXRoIGZvcndhcmRlciBzdGFjay5cblxuICAgIGF3YWl0IGNyZWF0ZUFXU0xhbWJkYUFSTihuZXcgdjEuQVdTTG9nc0ludGVncmF0aW9uQXBpKGNvbmZpZ3VyYXRpb24pLCBsYW1iZGFBcm4pXG4gICAgYXdhaXQgZW5hYmxlQVdTTG9nU2VydmljZXMobmV3IHYxLkFXU0xvZ3NJbnRlZ3JhdGlvbkFwaShjb25maWd1cmF0aW9uKSwgc2VydmljZXMpXG5cblxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQVdTTGFtYmRhQVJOKGFwaUluc3RhbmNlOiB2MS5BV1NMb2dzSW50ZWdyYXRpb25BcGksIGxhbWJkYUFybjogc3RyaW5nKSB7XG5cbiAgICBjb25zdCBwYXJhbXM6IHYxLkFXU0xvZ3NJbnRlZ3JhdGlvbkFwaUNyZWF0ZUFXU0xhbWJkYUFSTlJlcXVlc3QgPSB7XG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGFjY291bnRJZDogcHJvY2Vzcy5lbnYuQ0RLX0RFRkFVTFRfQUNDT1VOVCEsXG4gICAgICAgICAgICBsYW1iZGFBcm46IGxhbWJkYUFybixcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgYXdhaXQgYXBpSW5zdGFuY2VcbiAgICAgICAgLmNyZWF0ZUFXU0xhbWJkYUFSTihwYXJhbXMpXG4gICAgICAgIC50aGVuKChkYXRhOiBhbnkpID0+IGNvbnNvbGUubG9nKFwiW0RhdGFkb2ddIExhbWJkYSBJbnRlZ3JhdGlvbiBmb3IgbG9ncyBjcmVhdGVkXCIpKVxuICAgICAgICAuY2F0Y2goKGVycm9yOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gICAgICAgICAgICBleGl0KDEpXG4gICAgICAgIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5hYmxlQVdTTG9nU2VydmljZXMoYXBpSW5zdGFuY2U6IHYxLkFXU0xvZ3NJbnRlZ3JhdGlvbkFwaSwgc2VydmljZXMgPSBbXCJsYW1iZGFcIl0pIHtcblxuICAgIGNvbnN0IHBhcmFtczogdjEuQVdTTG9nc0ludGVncmF0aW9uQXBpRW5hYmxlQVdTTG9nU2VydmljZXNSZXF1ZXN0ID0ge1xuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBhY2NvdW50SWQ6IHByb2Nlc3MuZW52LkNES19ERUZBVUxUX0FDQ09VTlQhLFxuICAgICAgICAgICAgc2VydmljZXM6IHNlcnZpY2VzXG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIGF3YWl0IGFwaUluc3RhbmNlXG4gICAgICAgIC5lbmFibGVBV1NMb2dTZXJ2aWNlcyhwYXJhbXMpXG4gICAgICAgIC50aGVuKChkYXRhOiBhbnkpID0+IGNvbnNvbGUubG9nKGBbRGF0YWRvZ10gRW5hYmxlZCBzZXJ2aWNlcyBmb3IgJHtzZXJ2aWNlc31gKSlcbiAgICAgICAgLmNhdGNoKChlcnJvcjogYW55KSA9PiB7IGNvbnNvbGUuZXJyb3IoZXJyb3IpOyBleGl0KDEpIH0pO1xufVxuIl19